<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="None">
  <meta name="author" content="Yezy Ilomo">
  <link rel="shortcut icon" href="img/favicon.ico">
  <title>Home - Django RESTQL</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="css/theme.css" type="text/css" />
  <link rel="stylesheet" href="css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  <link href="extra.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Home";
    var mkdocs_page_input_path = "index.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="js/jquery-2.1.1.min.js" defer></script>
  <script src="js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="." class="icon icon-home"> Django RESTQL</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1 current">
		
    <a class="current" href=".">Home</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#introduction">Introduction</a></li>
    

    <li class="toctree-l2"><a href="#requirements">Requirements</a></li>
    

    <li class="toctree-l2"><a href="#installing">Installing</a></li>
    

    <li class="toctree-l2"><a href="#querying-data">Querying Data</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#querying-flat-fields">Querying flat fields</a></li>
        
            <li><a class="toctree-l3" href="#querying-nested-fields">Querying nested fields</a></li>
        
            <li><a class="toctree-l3" href="#exclude-operator">Exclude(-) operator</a></li>
        
            <li><a class="toctree-l3" href="#wildcard-operator">Wildcard(*) operator</a></li>
        
            <li><a class="toctree-l3" href="#dynamicserializermethodfield">DynamicSerializerMethodField</a></li>
        
            <li><a class="toctree-l3" href="#fields-and-exclude-kwargs">fields and exclude kwargs</a></li>
        
            <li><a class="toctree-l3" href="#return_pk-kwarg">return_pk kwarg</a></li>
        
            <li><a class="toctree-l3" href="#setting-up-eager-loading">Setting up eager loading</a></li>
        
            <li><a class="toctree-l3" href="#changing-query-parameter-name">Changing query parameter name</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#mutating-data">Mutating Data</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#using-nestedfield-nestedmodelserializer">Using NestedField &amp; NestedModelSerializer</a></li>
        
            <li><a class="toctree-l3" href="#using-nestedfield-with-accept_pk-kwarg">Using NestedField with accept_pk kwarg.</a></li>
        
            <li><a class="toctree-l3" href="#using-nestedfield-with-create_ops-and-update_ops-kwargs">Using NestedField with create_ops and update_ops kwargs.</a></li>
        
            <li><a class="toctree-l3" href="#using-dynamicfieldsmixin-and-nestedfield-together">Using DynamicFieldsMixin and NestedField together</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href=".">Django RESTQL</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".">Docs</a> &raquo;</li>
    
      
    
    <li>Home</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/yezyilomo/django-restql/edit/master/docs/index.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p><strong>django-restql</strong> is a python library which allows you to turn your API made with <strong>Django REST Framework(DRF)</strong> into a GraphQL like API. With <strong>django-restql</strong> you will be able to
* Send a query to your API and get exactly what you need, nothing more and nothing less.</p>
<ul>
<li>
<p>Control the data you get, not the server.</p>
</li>
<li>
<p>Get predictable results, since you control what you get from the server.</p>
</li>
<li>
<p>Get nested resources in a single request.</p>
</li>
<li>
<p>Avoid Over-fetching and Under-fetching of data.</p>
</li>
<li>
<p>Write(create &amp; update) nested data of any level with flexibility.</p>
</li>
</ul>
<p>Isn't it cool?.</p>
<h2 id="requirements">Requirements<a class="headerlink" href="#requirements" title="Permanent link">&para;</a></h2>
<ul>
<li>Python &gt;= 3.5</li>
<li>Django &gt;= 1.10</li>
<li>Django REST Framework &gt;= 3.5</li>
</ul>
<h2 id="installing">Installing<a class="headerlink" href="#installing" title="Permanent link">&para;</a></h2>
<pre><code class="py">pip install django-restql
</code></pre>

<h2 id="querying-data">Querying Data<a class="headerlink" href="#querying-data" title="Permanent link">&para;</a></h2>
<p>Using <strong>django-restql</strong> to query data is very simple, you just have to inherit the <code>DynamicFieldsMixin</code> class when defining a serializer that's all.</p>
<pre><code class="py">from rest_framework import serializers
from django.contrib.auth.models import User
from django_restql.mixins import DynamicFieldsMixin


class UserSerializer(DynamicFieldsMixin, serializer.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'username', 'email']
</code></pre>

<p>A regular request returns all fields as specified on a DRF serializer, in fact <strong>django-restql</strong> doesn't handle this request at all. Below is an example of regular request, as you see all fields are returned as specified on <code>UserSerializer</code>.</p>
<p><code>GET /users</code></p>
<pre><code class="js">[
    {
        &quot;id&quot;: 1,
        &quot;username&quot;: &quot;yezyilomo&quot;,
        &quot;email&quot;: &quot;yezileliilomo@hotmail.com&quot;,
    },
    ...
]
</code></pre>

<h3 id="querying-flat-fields">Querying flat fields<a class="headerlink" href="#querying-flat-fields" title="Permanent link">&para;</a></h3>
<p><strong>django-restql</strong> handle all GET requests with a <code>query</code> parameter, this parameter is the one used to pass all fields to be included/excluded in a response. For example to select <code>id</code> and <code>username</code> fields from User model, send a request with a <code>query</code> parameter as shown below.</p>
<p><code>GET /users/?query={id, username}</code></p>
<pre><code class="js">[
    {
        &quot;id&quot;: 1,
        &quot;username&quot;: &quot;yezyilomo&quot;
    },
    ...
]
</code></pre>

<h3 id="querying-nested-fields">Querying nested fields<a class="headerlink" href="#querying-nested-fields" title="Permanent link">&para;</a></h3>
<p><strong>django-restql</strong> support querying both flat and nested resources, so you can expand or query nested fields at any level as defined on a serializer. In an example below we have <code>location</code> and <code>groups</code> as nested fields on User model.</p>
<pre><code class="py">from rest_framework import serializers
from django.contrib.auth.models import User
from django_restql.mixins import DynamicFieldsMixin

from app.models import GroupSerializer, LocationSerializer


class GroupSerializer(DynamicFieldsMixin, serializer.ModelSerializer):
    class Meta:
        model = Group
        fields = ['id', 'name']


class LocationSerializer(DynamicFieldsMixin, serializer.ModelSerializer):
    class Meta:
        model = Location
        fields = ['id', 'country',  'city', 'street']


class UserSerializer(DynamicFieldsMixin, serializer.ModelSerializer):
    groups = GroupSerializer(many=True, read_only=True)
    location = LocationSerializer(many=False, read_only=True) 
    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'location', 'groups']
</code></pre>

<p>If you want only <code>country</code> and <code>city</code> fields on a <code>location</code> field when retrieving users here is how you can do it</p>
<p><code>GET /users/?query={id, username, location{country, city}}</code></p>
<pre><code class="js">[
    {
        &quot;id&quot;: 1,
        &quot;username&quot;: &quot;yezyilomo&quot;,
        &quot;location&quot;: {
            &quot;contry&quot;: &quot;Tanzania&quot;,
            &quot;city&quot;: &quot;Dar es salaam&quot;
        }
    },
    ...
]
</code></pre>

<h4 id="more-examples-to-get-you-comfortable-with-the-query-syntax">More examples to get you comfortable with the query syntax<a class="headerlink" href="#more-examples-to-get-you-comfortable-with-the-query-syntax" title="Permanent link">&para;</a></h4>
<p><code>GET /users/?query={location, groups}</code></p>
<pre><code class="js">[
    {
        &quot;location&quot;: {
            &quot;id&quot;: 1,
            &quot;contry&quot;: &quot;Tanzania&quot;,
            &quot;city&quot;: &quot;Dar es salaam&quot;,
            &quot;street&quot;: &quot;Oyster Bay&quot;
        }
        &quot;groups&quot;: [
            {&quot;id&quot;: 2, &quot;name&quot;: &quot;Auth_User&quot;},
            {&quot;id&quot;: 3, &quot;name&quot;: &quot;Admin_User&quot;}
        ]
    },
    ...
]
</code></pre>

<p><br/></p>
<p><code>GET /users/?query={id, username, groups{name}}</code></p>
<pre><code class="js">[
    {
        &quot;id&quot;: 1,
        &quot;username&quot;: &quot;yezyilomo&quot;,
        &quot;groups&quot;: [
            {&quot;name&quot;: &quot;Auth_User&quot;},
            {&quot;name&quot;: &quot;Admin_User&quot;}
        ]
    },
    ...
]
</code></pre>

<h3 id="exclude-operator">Exclude(-) operator<a class="headerlink" href="#exclude-operator" title="Permanent link">&para;</a></h3>
<p>When using <strong>django-restql</strong> filtering as-is is great if there are no many fields on a serializer, but sometimes you might have a case where you would like everything except a handful of fields on a larger serializer. These fields might be nested and trying the whitelist approach is difficult or possibly too long for the url. <strong>django-restql</strong> comes with the exclude operator(-) which can be used to exclude some fields in scenarios where you want to get all fields except few. Using exclude syntax is very simple,you just need to prepend the field to exclude with the exclude operator(-) when writing your query that's all. Take an example below</p>
<pre><code class="py">from rest_framework import serializers 
from django_restql.mixins import DynamicFieldsMixin

from app.models import Location, Property


class LocationSerializer(DynamicFieldsMixin, serializer.ModelSerializer):
    class Meta:
        model = Location
        fields = [&quot;id&quot;, &quot;city&quot;, &quot;country&quot;, &quot;state&quot;, &quot;street&quot;]


class PropertySerializer(DynamicFieldsMixin, serializer.ModelSerializer):
    location = LocationSerializer(many=False, read_only=True) 
    class Meta:
        model = Property
        fields = [
            'id', 'price', 'location'
        ]
</code></pre>

<p>Get all location fields except <code>id</code> and <code>street</code></p>
<p><code>GET /location/?query={-id, -street}</code></p>
<pre><code class="js">[
    {
        &quot;country&quot;: &quot;China&quot;,
        &quot;city&quot;: &quot;Beijing&quot;,
        &quot;state&quot;: &quot;Chaoyang&quot;
    },
    ...
]
</code></pre>

<p>This is equivalent to <code>query={country, city, state}</code></p>
<p>You can use exclude operator on nested fields too, for example if you want to get <code>price</code> and <code>location</code> fields but under <code>location</code> you want all fields except <code>id</code> here is how you can do it.</p>
<p><code>GET /property/?query={price, location{-id}}</code></p>
<pre><code class="js">[
    {
        &quot;price&quot;: 5000
        &quot;location&quot;: {
            &quot;country&quot;: &quot;China&quot;,
            &quot;city&quot; &quot;Beijing&quot;,
            &quot;state&quot;: &quot;Chaoyang&quot;,
            &quot;street&quot;: &quot;Hanang&quot;
        }
    },
    ...
]
</code></pre>

<p>This is equivalent to <code>query={price, location{country, city, state, street}}</code></p>
<h4 id="more-examples-to-get-you-comfortable-with-the-exclude-operator-syntax">More examples to get you comfortable with the exclude operator(-) syntax<a class="headerlink" href="#more-examples-to-get-you-comfortable-with-the-exclude-operator-syntax" title="Permanent link">&para;</a></h4>
<p>Assuming this is the structure of the model we are querying</p>
<pre><code class="py">data = {
    username,
    birthdate,
    location {
        country,
        city
    },
    contact {
        phone,
        email
    }
}
</code></pre>

<p>Here is how we can structure our query to exclude some fields using exclude operator(-)</p>
<pre><code class="py">{-username}   ≡   {birthdate, location{country, city}, contact{phone, email}}

{-username, contact{phone}, location{country}}   ≡    {birthdate ,contact{phone}, location{country}}

{-contact, location{country}}   ≡    {username, birthdate, location{country}}

{-contact, -location}   ≡    {username, birthdate}

{username, location{-country}}   ≡    {username, location{city}}

{username, location{-city}, contact{-email}}   ≡    {username, location{country}, contact{phone}}
</code></pre>

<h3 id="wildcard-operator">Wildcard(*) operator<a class="headerlink" href="#wildcard-operator" title="Permanent link">&para;</a></h3>
<p>In addition to exclude operator(-), <strong>django-restql</strong> comes with a wildcard(*) operator for including all fields. Just like exclude operator(-) using a wildcard operator(*) is very simple, for example if you want to get all fields from a model you just need to do <code>query={*}</code>. This operator can be used to simplify some filtering which might endup being very long if done with other approaches. For example if you have a model with this format </p>
<pre><code class="py">user = {
    username,
    birthdate,
    contact {
        phone,
        email,
        twitter,
        github,
        linkedin,
        facebook
    }
}
</code></pre>

<p>Let's say you want to get all user fields but under <code>contact</code> field you want to get only <code>phone</code>, you could use the whitelisting approach as <code>query={username, birthdate, contact{phone}}</code> but if you have many fields on user model you might endup writing a very long query, so with <code>*</code> operator you can simply do <code>query={*, contace{phone}}</code> which means get me all fields on user model but under <code>contact</code> field I want only <code>phone</code> field, as you see the query is very short compared to the first one and it won't grow if more fields are added to the user model.</p>
<h4 id="more-examples-to-get-you-comfortable-with-the-wildcard-operator42-syntax">More examples to get you comfortable with the wildcard operator(*) syntax<a class="headerlink" href="#more-examples-to-get-you-comfortable-with-the-wildcard-operator42-syntax" title="Permanent link">&para;</a></h4>
<pre><code class="py">{*, -username, contact{phone}}   ≡   {birthdate, contact{phone}}

{username, contact{*, -facebook, -linkedin}}   ≡   {username, contact{phone, email, twitter, github}}

{*, -username, contact{*, -facebook, -linkedin}}   ≡   {birthdate, contact{phone, email, twitter, github}}
</code></pre>

<pre><code class="py"># These may happen accidentally as it's very easy/tempting to make 
# these kind of mistakes with the exclude operator(-) and wildcard operator(*) syntax, 
{username, -location{country}}  # Syntax error(Should not expand excluded field)
{-username, birthdate}   # Syntax error(Should not whitelist and blacklist fields at the same field level)
{*username}  # Syntax error (What are you even trying to accomplish)
{*location{country}}  # Syntax error (This is def wrong)
</code></pre>

<p><strong>Note:</strong> Any field level should either be whitelisting or blacklisting fields but not both.
<br/></p>
<h3 id="dynamicserializermethodfield"><code>DynamicSerializerMethodField</code><a class="headerlink" href="#dynamicserializermethodfield" title="Permanent link">&para;</a></h3>
<p><code>DynamicSerializerMethodField</code> is a wraper of the <code>SerializerMethodField</code>, it adds a query argument from a parent serializer to a method bound to a <code>SerializerMethodField</code>, this query argument can be passed to a serializer used within a method to allow further querying. For example in the scenario below we are using <code>DynamicSerializerMethodField</code> because we want to be able to query <code>tomes</code> field.</p>
<pre><code class="py">from django_restql.mixins import DynamicFieldsMixin
from django_restql.fields import DynamicSerializerMethodField


class CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    # Use `DynamicSerializerMethodField` instead of `SerializerMethodField`
    # if you want to be able to query `tomes`
    tomes = DynamicSerializerMethodField()
    class Meta:
        model = Course
        fields = ['name', 'code', 'tomes']

    def get_tomes(self, obj, query):
        # With `DynamicSerializerMethodField` you get this extra
        # `query` argument in addition to `obj`
        books = obj.books.all()

        # You can do what ever you want in here

        # `query` param and context are passed to BookSerializer to allow querying it
        serializer = BookSerializer(books, query=query, many=True, context=self.context)
        return serializer.data
</code></pre>

<p><code>GET /course/?query={name, tomes}</code></p>
<pre><code class="js">[
    {
        &quot;name&quot;: &quot;Data Structures&quot;,
        &quot;tomes&quot;: [
            {&quot;title&quot;: &quot;Advanced Data Structures&quot;, &quot;author&quot;: &quot;S.Mobit&quot;},
            {&quot;title&quot;: &quot;Basic Data Structures&quot;, &quot;author&quot;: &quot;S.Mobit&quot;}
        ]
    }
]
</code></pre>

<p><br/></p>
<p><code>GET /course/?query={name, tomes{title}}</code></p>
<pre><code class="js">[
    {
        &quot;name&quot;: &quot;Data Structures&quot;,
        &quot;tomes&quot;: [
            {&quot;title&quot;: &quot;Advanced Data Structures&quot;},
            {&quot;title&quot;: &quot;Basic Data Structures&quot;}
        ]
    }
]
</code></pre>

<p><br/></p>
<h3 id="fields-and-exclude-kwargs"><code>fields</code> and <code>exclude</code> kwargs<a class="headerlink" href="#fields-and-exclude-kwargs" title="Permanent link">&para;</a></h3>
<p>With <strong>django-restql</strong> you can specify fields to be included when instantiating a serializer, this provides a way to refilter fields on nested fields(i.e you can opt to remove some fields on a nested field). Below is an example which shows how you can specify fields to be included on nested resources. </p>
<pre><code class="py">from rest_framework import serializers
from django.contrib.auth.models import User
from django_restql.mixins import DynamicFieldsMixin

from app.models import Book, Course


class BookSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = ['id', 'title', 'author']


class CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    books = BookSerializer(many=True, read_only=True, fields=[&quot;title&quot;])
    class Meta:
        model = Course
        fields = ['name', 'code', 'books']
</code></pre>

<p><code>GET /courses/</code></p>
<pre><code class="js">[
    {
        &quot;name&quot;: &quot;Computer Programming&quot;,
        &quot;code&quot;: &quot;CS50&quot;,
        &quot;books&quot;: [
            {&quot;title&quot;: &quot;Computer Programming Basics&quot;},
            {&quot;title&quot;: &quot;Data structures&quot;}
        ]
    },
    ...
]
</code></pre>

<p>As you see from the response above, the nested resource(book) has only one field(title) as specified on  <code>fields=["title"]</code> kwarg during instantiating BookSerializer, so if you send a request like <code>GET /course?query={name, code, books{title, author}}</code> you will get an error that <code>author</code> field is not found because it was not included on <code>fields=["title"]</code> kwarg.</p>
<p>You can also specify fields to be excluded when instantiating a serializer by using <code>exclude=[]</code> as shown below </p>
<pre><code class="py">from rest_framework import serializers
from django_restql.mixins import DynamicFieldsMixin

from app.models import Book, Course


class BookSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = ['id', 'title', 'author']


class CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    books = BookSerializer(many=True, read_only=True, exclude=[&quot;author&quot;])
    class Meta:
        model = Course
        fields = ['name', 'code', 'books']
</code></pre>

<p><code>GET /courses/</code></p>
<pre><code class="js">[
    {
        &quot;name&quot;: &quot;Computer Programming&quot;,
        &quot;code&quot;: &quot;CS50&quot;,
        &quot;books&quot;: [
            {&quot;id&quot;: 1, &quot;title&quot;: &quot;Computer Programming Basics&quot;},
            {&quot;id&quot;: 2, &quot;title&quot;: &quot;Data structures&quot;}
        ]
    },
    ...
]
</code></pre>

<p>From the response above you can see that <code>author</code> field has been excluded fom book nested resource as specified on  <code>exclude=["author"]</code> kwarg during instantiating BookSerializer.</p>
<p><strong>Note:</strong> <code>fields</code> and <code>exclude</code> kwargs have no effect when you access the resources directly, so when you access books you will still get all fields i.e</p>
<p><code>GET /books/</code></p>
<pre><code class="js">[
    {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;Computer Programming Basics&quot;,
        &quot;author&quot;: &quot;S.Mobit&quot;
    },
    ...
]
</code></pre>

<p>So you can see that all fields have appeared as specified on <code>fields = ['id', 'title', 'author']</code> on BookSerializer class.
<br/></p>
<h3 id="return_pk-kwarg"><code>return_pk</code> kwarg<a class="headerlink" href="#return_pk-kwarg" title="Permanent link">&para;</a></h3>
<p>With <strong>django-restql</strong> you can specify whether to return nested resource pk or data. Below is an example which shows how we can specify fields to be included on nested resources. </p>
<pre><code class="py">from rest_framework import serializers
from django_restql.mixins import DynamicFieldsMixin

from app.models import Book, Course


class BookSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = ['id', 'title', 'author']


class CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    books = BookSerializer(many=True, read_only=True, return_pk=True)
    class Meta:
        model = Course
        fields = ['name', 'code', 'books']
</code></pre>

<p><code>GET /course/</code></p>
<pre><code class="js">[
    {
        &quot;name&quot;: &quot;Computer Programming&quot;,
        &quot;code&quot;: &quot;CS50&quot;,
        &quot;books&quot;: [1, 2]
    },
    ...
]
</code></pre>

<p>So you can see that on a nested field <code>books</code> book pks have been returned instead of books data as specified on <code>return_pk=True</code> kwarg on <code>BookSerializer</code>.
<br/></p>
<h3 id="setting-up-eager-loading">Setting up eager loading<a class="headerlink" href="#setting-up-eager-loading" title="Permanent link">&para;</a></h3>
<p>Often times, using <code>prefetch_related</code> or <code>select_related</code> on a view queryset can help speed up the serialization. For example, if you had a many-to-many relation like Books to a Course, it's usually more efficient to call <code>prefetch_related</code> on the books so that serializing a list of courses only triggers one additional query, instead of a number of queries equal to the number of courses.</p>
<p><code>EagerLoadingMixin</code> gives access to <code>prefetch_related</code> and <code>select_related</code> properties, these two are dictionaries that match serializer field names to respective values that would be passed into <code>prefetch_related</code> or <code>select_related</code>. Take the following serializers as examples.</p>
<pre><code class="py">class CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    books = BookSerializer(many=True, read_only=True)

    class Meta:
        model = Course
        fields = ['name', 'code', 'books']

class StudentSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    program = CourseSerializer(source=&quot;course&quot;, many=False, read_only=True)
    phone_numbers = PhoneSerializer(many=True, read_only=True)

    class Meta:
        model = Student
        fields = ['name', 'age', 'program', 'phone_numbers']
</code></pre>

<p>In a view, these can be used as described earlier in this documentation. However, if prefetching of <code>books</code> always happened, but we did not ask for <code>{program}</code> or <code>program{books}</code>, then we did an additional query for nothing. Conversely, not prefetching can lead to even more queries being triggered. When leveraging the <code>EagerLoadingMixin</code> on a view, the specific fields that warrant a <code>select_related</code> or <code>prefetch_related</code> can be described.</p>
<h4 id="syntax-for-prefetch_related-and-select_related">Syntax for <code>prefetch_related</code> and <code>select_related</code><a class="headerlink" href="#syntax-for-prefetch_related-and-select_related" title="Permanent link">&para;</a></h4>
<p>The format of syntax for <code>select_related</code> and  <code>prefetch_related</code> is as follows</p>
<pre><code class="py">select_related = {&quot;serializer_field_name&quot;: [&quot;field_to_select&quot;]}
prefetch_related = {&quot;serializer_field_name&quot;: [&quot;field_to_prefetch&quot;]}
</code></pre>

<p>If you are selecting or prefetching one field per serializer field name you can use</p>
<pre><code class="py">select_related = {&quot;serializer_field_name&quot;: &quot;field_to_select&quot;}
prefetch_related = {&quot;serializer_field_name&quot;: &quot;field_to_prefetch&quot;}
</code></pre>

<p><strong>Syntax Interpretation</strong>
- <code>serializer_field_name</code> stands for the name of the field to prefetch or select(as named on a serializer)
- <code>fields_to_select</code> stands for argument(s) to pass when calling <code>select_related</code> method
- <code>fields_to_prefetch</code> stands for arguments(s) to pass when calling <code>prefetch_related</code> method
- If you want to select or prefetch nested field use dot(.) to separate parent and child fields on <code>serializer_field_name</code> eg <code>parent.child</code></p>
<h4 id="example-of-eagerloadingmixin-usage">Example of <code>EagerLoadingMixin</code> usage<a class="headerlink" href="#example-of-eagerloadingmixin-usage" title="Permanent link">&para;</a></h4>
<pre><code class="py">from rest_framework import viewsets
from django_restql.mixins import EagerLoadingMixin
from myapp.serializers import StudentSerializer
from myapp.models import Student

class StudentViewSet(EagerLoadingMixin, viewsets.ModelViewSet):
    serializer_class = StudentSerializer
    queryset = Student.objects.all()

    # The Interpretation of this is 
    # Select `course` only if program field is included in a query
    select_related = {
        &quot;program&quot;: &quot;course&quot;
    }

    # The Interpretation of this is 
    # Prefetch `course__books` only if program or program.books 
    # fields are included in a query
    prefetch_related = {
        &quot;program.books&quot;: &quot;course__books&quot;
    }
</code></pre>

<h4 id="example-queries">Example Queries<a class="headerlink" href="#example-queries" title="Permanent link">&para;</a></h4>
<ul>
<li><code>{name}</code></li>
</ul>
<p>Neither <code>select_related</code> or <code>prefetch_related</code> will be run since neither field is present on the serializer for this query.</p>
<ul>
<li><code>{program}</code></li>
</ul>
<p>Both <code>select_related</code> and <code>prefetch_related</code> will be run, since <code>program</code> is present in it's entirety (including the <code>books</code> field).</p>
<ul>
<li><code>{program{name}}</code></li>
</ul>
<p>Only <code>select_related</code> will be run, since <code>books</code> are not present on the program fields.</p>
<ul>
<li><code>{program{books}}</code></li>
</ul>
<p>Both will be run here as well, since this explicitly fetches books.</p>
<h4 id="more-example-to-get-you-comfortable-with-select_related-and-prefetch_related-syntax">More example to get you comfortable with <code>select_related</code> and <code>prefetch_related</code> syntax<a class="headerlink" href="#more-example-to-get-you-comfortable-with-select_related-and-prefetch_related-syntax" title="Permanent link">&para;</a></h4>
<p>Assuming this is the structure of the model and corresponding field types </p>
<pre><code class="py">user = {
    username,        # string
    birthdate,       # string
    location {       # foreign key related field
        country,     # string
        city         # string
    },
    contact {        # foreign key related field
        email,       # string
        phone {      # foreign key related field
            number,  # string
            type     # string
        }
    }
    articles {       # many related field
        title,       # string
        body,        # text
        reviewers {  # many related field
            name,    # string
            rating   # number
        }
    }
}
</code></pre>

<p>Here is how <code>select_related</code> and <code>prefetch_related</code> should be written for this model</p>
<pre><code class="py">select_related = {
    &quot;location&quot;: &quot;location&quot;,
    &quot;contact&quot;: &quot;contact&quot;,
    &quot;contact.phone&quot;: &quot;contact__phone
}

prefetch_related = {
    &quot;articles&quot;: &quot;articles&quot;
    &quot;articles.reviews&quot;: &quot;articles__reviewers&quot;
}
</code></pre>

<h4 id="known-caveats">Known Caveats<a class="headerlink" href="#known-caveats" title="Permanent link">&para;</a></h4>
<p>When prefetching with a <code>to_attr</code>, ensure that there are no collisions. Django does not allow multiple prefetches with the same <code>to_attr</code> on the same queryset.</p>
<p>When prefetching <em>and</em> calling <code>select_related</code> on a field, Django may error, since the ORM does allow prefetching a selectable field, but not both at the same time.</p>
<h3 id="changing-query-parameter-name">Changing <code>query</code> parameter name<a class="headerlink" href="#changing-query-parameter-name" title="Permanent link">&para;</a></h3>
<p>If you don't want to use the name <code>query</code> as your parameter, you can inherit <code>DynamicFieldsMixin</code> and change it as shown below</p>
<pre><code class="py">from django_restql.mixins import DynamicFieldsMixin
class MyDynamicFieldMixin(DynamicFieldsMixin):
    query_param_name = &quot;your_favourite_name&quot;
</code></pre>

<p>Now you can use this Mixin on your serializer and use the name <code>your_favourite_name</code> as your parameter. E.g</p>
<p><code>GET /users/?your_favourite_name={id, username}</code></p>
<h2 id="mutating-data">Mutating Data<a class="headerlink" href="#mutating-data" title="Permanent link">&para;</a></h2>
<p><strong>django-restql</strong> got your back on creating and updating nested data too, it has two components for mutating nested data, <code>NestedModelSerializer</code> and <code>NestedField</code>. A serializer <code>NestedModelSerializer</code> has <code>update</code> and <code>create</code> logics for nested fields on the other hand <code>NestedField</code> is used to validate data before dispatching update or create.</p>
<h3 id="using-nestedfield-nestedmodelserializer">Using NestedField &amp; NestedModelSerializer<a class="headerlink" href="#using-nestedfield-nestedmodelserializer" title="Permanent link">&para;</a></h3>
<p>Just like in querying data, mutating nested data with <strong>django-restql</strong> is very simple, you just have to inherit <code>NestedModelSerializer</code> on a serializer with nested fields and use <code>NestedField</code> to define those nested fields. Below is an example which shows how to use <code>NestedModelSerializer</code> and <code>NestedField</code>.</p>
<pre><code class="py">from rest_framework import serializers
from django_restql.serializers import NestedModelSerializer
from django_restql.fields import NestedField

from app.models import Location, Amenity, Property


class LocationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Location
        fields = [&quot;id&quot;, &quot;city&quot;, &quot;country&quot;]


class AmenitySerializer(serializers.ModelSerializer):
    class Meta:
        model = Amenity
        fields = [&quot;id&quot;, &quot;name&quot;]


# Inherit NestedModelSerializer to support create and update 
# on nested fields
class PropertySerializer(NestedModelSerializer):
    location = NestedField(LocationSerializer)  # Define location as nested field
    amenities = NestedField(AmenitySerializer, many=True)  # Define amenities as nested field
    class Meta:
        model = Property
        fields = [
            'id', 'price', 'location', 'amenities'
        ]
</code></pre>

<p><br></p>
<p><code>POST /api/property/</code></p>
<p>Request Body</p>
<pre><code class="js">{
    &quot;price&quot;: 60000,
    &quot;location&quot;: {
        &quot;city&quot;: &quot;Newyork&quot;,
        &quot;country&quot;: &quot;USA&quot;
    },
    &quot;amenities&quot;: {
        &quot;add&quot;: [3],
        &quot;create&quot;: [
            {&quot;name&quot;: &quot;Watererr&quot;},
            {&quot;name&quot;: &quot;Electricity&quot;}
        ]
    }
}
</code></pre>

<p>What's done here is pretty clear, location will be created and associated with the property created, also create operation on amenities will create amenities with values specified in a list and associate with the property, add operation will add amenity with id 4 to a list of amenities of the property.</p>
<p><strong>Note:</strong> POST for many related field supports two operations which are <code>create</code> and <code>add</code>.</p>
<p>Response</p>
<pre><code class="js">{
    &quot;id&quot;: 2,
    &quot;price&quot;: 60000,
    &quot;location&quot;: {
        &quot;id&quot;: 3,
        &quot;city&quot;: &quot;Newyork&quot;,
        &quot;country&quot;: &quot;USA&quot;
    },
    &quot;amenities&quot;: [
        {&quot;id&quot;: 1, &quot;name&quot;: &quot;Watererr&quot;},
        {&quot;id&quot;: 2, &quot;name&quot;: &quot;Electricity&quot;},
        {&quot;id&quot;: 3, &quot;name&quot;: &quot;Swimming Pool&quot;}
    ]
}
</code></pre>

<p><br></p>
<p><code>PUT /api/property/2/</code></p>
<p>Request Body</p>
<pre><code class="js">{
    &quot;price&quot;: 50000,
    &quot;location&quot;: {
        &quot;city&quot;: &quot;Newyork&quot;,
        &quot;country&quot;: &quot;USA&quot;
    },
    &quot;amenities&quot;: {
        &quot;add&quot;: [4],
        &quot;create&quot;: [{&quot;name&quot;: &quot;Fance&quot;}],
        &quot;remove&quot;: [3],
        &quot;update&quot;: {1: {&quot;name&quot;: &quot;Water&quot;}}
    }
}
</code></pre>

<p><strong>Note:</strong> Here <code>add</code>, <code>create</code>, <code>remove</code> and <code>update</code> are operations, so <code>add</code> operation add amenitiy with id 4 to a list of amenities of the property, <code>create</code> operation create amenities with values specified in a list, <code>remove</code> operation dessociate amenities with id 3 from a property, <code>update</code> operation edit amenity with id 1 according to values specified.</p>
<p><strong>Note:</strong> PUT/PATCH for many related field supports four operations which are <code>create</code>, <code>add</code>, <code>remove</code> and <code>update</code>.</p>
<p>Response</p>
<pre><code class="js">{
    &quot;id&quot;: 2,
    &quot;price&quot;: 50000,
    &quot;location&quot;: {
        &quot;id&quot;: 3,
        &quot;city&quot;: &quot;Newyork&quot;,
        &quot;country&quot;: &quot;USA&quot;
    },
    &quot;amenities&quot;: [
        {&quot;id&quot;: 1, &quot;name&quot;: &quot;Water&quot;},
        {&quot;id&quot;: 2, &quot;name&quot;: &quot;Electricity&quot;},
        {&quot;id&quot;: 4, &quot;name&quot;: &quot;Bathtub&quot;},
        {&quot;id&quot;: 5, &quot;name&quot;: &quot;Fance&quot;}
    ]
}
</code></pre>

<p><br></p>
<h3 id="using-nestedfield-with-accept_pk-kwarg">Using NestedField with <code>accept_pk</code> kwarg.<a class="headerlink" href="#using-nestedfield-with-accept_pk-kwarg" title="Permanent link">&para;</a></h3>
<p><code>accept_pk=True</code> is used if you want to update nested field by using pk/id of existing data(basically associate and dessociate existing nested resources with the parent resource without actually mutating the nested resource). This applies to ForeignKey relation only.</p>
<pre><code class="py">from rest_framework import serializers 
from django_restql.fields import NestedField
from django_restql.serializers import NestedModelSerializer

from app.models import Location, Property


class LocationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Location
        fields = [&quot;id&quot;, &quot;city&quot;, &quot;country&quot;]


class PropertySerializer(NestedModelSerializer):
    location = NestedField(LocationSerializer, accept_pk=True)  # pk based nested field
    class Meta:
        model = Property
        fields = [
            'id', 'price', 'location'
        ]
</code></pre>

<p><br></p>
<p><code>POST /api/property/</code></p>
<p>Request Body</p>
<pre><code class="js">{
    &quot;price&quot;: 40000,
    &quot;location&quot;: 2
}
</code></pre>

<p><strong>Note:</strong> Here location resource with id 2 is already existing, so what's done here is create new property resource and associate it with a location with id 2.
<br></p>
<p>Response</p>
<pre><code class="js">{
    &quot;id&quot;: 1,
    &quot;price&quot;: 40000,
    &quot;location&quot;: {
        &quot;id&quot;: 2,
        &quot;city&quot;: &quot;Tokyo&quot;,
        &quot;country&quot;: &quot;China&quot;
    }
}
</code></pre>

<p><br></p>
<h3 id="using-nestedfield-with-create_ops-and-update_ops-kwargs">Using NestedField with <code>create_ops</code> and <code>update_ops</code> kwargs.<a class="headerlink" href="#using-nestedfield-with-create_ops-and-update_ops-kwargs" title="Permanent link">&para;</a></h3>
<p>You can restrict some operations by using <code>create_ops</code> and <code>update_ops</code> keyword arguments as follows</p>
<pre><code class="py">from rest_framework import serializers 
from django_restql.fields import NestedField
from django_restql.serializers import NestedModelSerializer 

from app.models import Location, Amenity, Property


class AmenitySerializer(serializers.ModelSerializer):
    class Meta:
        model = Amenity
        fields = [&quot;id&quot;, &quot;name&quot;]


class PropertySerializer(NestedModelSerializer):
    amenities = NestedField(
        AmenitySerializer, 
        many=True,
        create_ops=[&quot;add&quot;],  # Allow only add operation
        update_ops=[&quot;add&quot;, &quot;remove&quot;]  # Allow only add and remove operations
    )
    class Meta:
        model = Property
        fields = [
            'id', 'price', 'amenities'
        ]
</code></pre>

<p><br></p>
<p><code>POST /api/property/</code></p>
<p>Request Body</p>
<pre><code class="js">{
    &quot;price&quot;: 60000,
    &quot;amenities&quot;: {
        &quot;add&quot;: [1, 2]
    }
}
</code></pre>

<p><strong>Note:</strong> According to <code>create_ops=["add"]</code>, you can't use <code>create</code> operation in here!.
<br></p>
<p>Response</p>
<pre><code class="js">{
    &quot;id&quot;: 2,
    &quot;price&quot;: 60000,
    &quot;amenities&quot;: [
        {&quot;id&quot;: 1, &quot;name&quot;: &quot;Watererr&quot;},
        {&quot;id&quot;: 2, &quot;name&quot;: &quot;Electricity&quot;}
    ]
}
</code></pre>

<p><br></p>
<p><code>PUT /api/property/2/</code></p>
<p>Request Body</p>
<pre><code class="js">{
    &quot;price&quot;: 50000,
    &quot;amenities&quot;: {
        &quot;add&quot;: [3],
        &quot;remove&quot;: [2]
    }
}
</code></pre>

<p><strong>Note:</strong> According to <code>update_ops=["add", "remove"]</code>, you can't use <code>create</code> or <code>update</code> operation in here!.
<br></p>
<p>Response</p>
<pre><code class="js">{
    &quot;id&quot;: 2,
    &quot;price&quot;: 50000,
    &quot;amenities&quot;: [
        {&quot;id&quot;: 1, &quot;name&quot;: &quot;Water&quot;},
        {&quot;id&quot;: 3, &quot;name&quot;: &quot;Bathtub&quot;}
    ]
}
</code></pre>

<p><br></p>
<h3 id="using-dynamicfieldsmixin-and-nestedfield-together">Using <code>DynamicFieldsMixin</code> and <code>NestedField</code> together<a class="headerlink" href="#using-dynamicfieldsmixin-and-nestedfield-together" title="Permanent link">&para;</a></h3>
<p>You can use <code>DynamicFieldsMixin</code> and <code>NestedModelSerializer</code> together if you want your serializer to be writable(on nested fields) and support querying data, this is very common. Below is an example which shows how you can use <code>DynamicFieldsMixin</code> and <code>NestedField</code> together.</p>
<pre><code class="py">from rest_framework import serializers 
from django_restql.fields import NestedField
from django_restql.mixins import DynamicFieldsMixin
from django_restql.serializers import NestedModelSerializer 

from app.models import Location, Property


class LocationSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    class Meta:
        model = Location
        fields = [&quot;id&quot;, &quot;city&quot;, &quot;country&quot;]

# Inherit both DynamicFieldsMixin and NestedModelSerializer
class PropertySerializer(DynamicFieldsMixin, NestedModelSerializer):
    location = NestedField(LocationSerializer)
    class Meta:
        model = Property
        fields = [
            'id', 'price', 'location'
        ]
</code></pre>

<p><code>NestedField</code> is nothing but a serializer wrapper, it returns an instance of a modified version of a serializer passed, so you can pass all the args and kwargs accepted by a serializer on it, it will simply pass them to a serializer passed when instantiating an instance. So you can pass anything accepted by a serializer to a <code>NestedField</code> wrapper, and if a serializer passed inherits <code>DynamicFieldsMini</code> just like <code>LocationSerializer</code> on above example then you can pass any arg or kwarg accepted by <code>DynamicFieldsMixin</code> when defining location as a nested field, i.e</p>
<pre><code class="py">location = NestedField(LocationSerializer, fields=[...])
</code></pre>

<pre><code class="py">location = NestedField(LocationSerializer, exclude=[...])
</code></pre>

<pre><code class="py">location = NestedField(LocationSerializer, return_pk=True)
</code></pre>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/yezyilomo/django-restql/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
      
    </span>
</div>
    <script>var base_url = '.';</script>
    <script src="js/theme.js" defer></script>
      <script src="search/main.js" defer></script>

</body>
</html>

<!--
MkDocs version : 1.0.4
Build Date UTC : 2019-11-23 20:33:55
-->
